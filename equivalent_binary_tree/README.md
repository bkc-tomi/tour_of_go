# Equivalent Binary Tree
このエクササイズではゴルーチンとチャンネルを駆使して二分木探索を行います。
もう少し詳しく説明すると、２つの二分木を探索して値を取り出しそれが一致すれば真、そうでなければ偽を返す
関数を実装します。つまり二つの二分木が同一かどうかを判定するプログラムを作るということです。
<br>
ちなみに二分木とは以下のように枝が生えているように図で表すことのできるデータ構造のことを指します。
また枝は２つまでしか別れません。「左の子孫の値 ≤ 親 ≤ 右の子孫の値」という制約を持ちます。
二分木の図の書き方にもよりますが、左から順に値が大きくなっていくということです。

![binary_tree]("./binary_tree.png")

このエクササイズでは、tree型という構造体が与えられています。

```
type Tree struct {
    Left  *Tree
    Value int
    Right *Tree
}
```

この構造体にはNewというメソッドが与えられていて、tree.New(k)でランダムな構造の二分木を生成することが出来ます。
tree.New(k)で生成された二分木は、
<br>
k, 2k, ..., 10k
<br>
の値を持っています。例えば、tree.New(3)だと
<br>
3, 6, ..., 30
<br>
の値を持った二分木が生成されます(値は必ず同じですが構造(木の形)が異なります)。
以下は単純に二分木を出力した場合の結果です。参考までに

```
package main

import (
	"fmt"
	"golang.org/x/tour/tree"
)

func main() {
	i := 1
	for {
		fmt.Println(tree.New(i))
		i++
		if i >= 9 {
			break
		}
	}
}

実行結果
((((1 (2)) 3 (4)) 5 ((6) 7 ((8) 9))) 10)
((((2) 4 (6)) 8 (10 (12))) 14 ((16) 18 (20)))
((((((3) 6) 9 (12)) 15 (18)) 21) 24 ((27) 30))
((4 ((((8) 12 (16)) 20) 24)) 28 ((32) 36 (40)))
((5) 10 ((((15 (20)) 25 ((30) 35)) 40) 45 (50)))
((((6 (12)) 18) 24) 30 (36 ((42) 48 ((54) 60))))
((((7 (14)) 21 (28)) 35 (42)) 49 (56 (63 (70))))
((8 (((16) 24 (32)) 40 (48 (((56) 64) 72)))) 80)

```

みての通り、単純に出力すれば、かっこで枝を表現しているので少しわかりにくいです。

<br>
例えtree.New(1)を10回繰り返し出力使用が木の構造か異なります。しかし、左から探索していくと1, 2, ..., 10
と必ず同じ値がとり出せます。つまり木の構造は異なるが同一視できるということです。
<br>
このエクササイズでは与えられた二分木を探索するWalk関数と、それを利用して与えられた二つの二分木が同一視できるかどうか、できるならばtrue, 出来ないならfalseを返すSame関数を「ゴルーチンとチャンネルを使って」実装してくれという問題です。並行処理を行う場所に気をつけてください。
<br>
ゴルーチン、チャンネルについて詳しく知りたい場合はchannelディレクトリを見てみてください。

[Exercise: Equivalent Binary Trees](https://tour.golang.org/concurrency/8)