# Fibonacci Closure
普通の関数は呼び出された時に実行して終わると処理内容の一切を破棄します。なので呼び出されるたび前回の処理内容を呼び出して変更を加えるようなことは出来ません(例えば呼び出される度に値が増えていくカウントアップなど)。

そこで出てくるのがクロージャー関数です。クロージャーは関数内に別の関数を内包しています。以下の例がわかりやすいと思います。adder()は中に無名関数を持っているのでクロージャー関数です。goにおいてはクロージャー関数は返り値に関数を持ちます。main内で変数fにadder()を代入し実行すると、実行毎に中の無名関数が呼ばれます。無名関数ではクロージャー関数が持つ変数sumがインクリメントされるのでf()が実行される度に値が増えていきます。
```
func adder() func() int {
	sum := 0
	return func() int {
		sum++
		return sum
	}
}

func main() {
	f := adder()
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())
}
// 実行結果
1
2
3
```
クロージャー関数は今回のフィボナッチ数列のように**前回の結果から今回の結果を求めるような処理**をする際に有効的です。フィボナッチ数列は以下のような式で定義されている数列です。

<img src="https://latex.codecogs.com/gif.latex?a_{n3}&space;=&space;a_{n2}&space;&plus;&space;a_{n1}" title="a_{n3} = a_{n2} + a_{n1}" />

数式に日頃親しんでない方には複雑に見えるかもしれませんが、要は前に求めた２つから次の値を求めましょうということを式で表現しただけです。なのでフィボナッチ数列では最初の値は二つは一般的に0と1を与えてあります(数列は[0, 1])。なので次の値は２つを足した１になり数列は[0, 1, 1]。次は前の２つを足した２になるので数列は[0, 1, 1, 2]となっていきます。[Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0)

[Exercise: Fibonacci closure](https://tour.golang.org/moretypes/26)